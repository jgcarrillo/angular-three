"use strict";(self.webpackChunklibs_documentations=self.webpackChunklibs_documentations||[]).push([[186],{9613:function(e,n,t){t.d(n,{Zo:function(){return p},kt:function(){return h}});var a=t(9496);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var l=a.createContext({}),c=function(e){var n=a.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},p=function(e){var n=c(e.components);return a.createElement(l.Provider,{value:n},e.children)},m={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},d=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,o=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),d=c(t),h=r,u=d["".concat(l,".").concat(h)]||d[h]||m[h]||o;return t?a.createElement(u,i(i({ref:n},p),{},{components:t})):a.createElement(u,i({ref:n},p))}));function h(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var o=t.length,i=new Array(o);i[0]=d;var s={};for(var l in n)hasOwnProperty.call(n,l)&&(s[l]=n[l]);s.originalType=e,s.mdxType="string"==typeof e?e:r,i[1]=s;for(var c=2;c<o;c++)i[c]=t[c];return a.createElement.apply(null,i)}return a.createElement.apply(null,t)}d.displayName="MDXCreateElement"},7688:function(e,n,t){t.r(n),t.d(n,{assets:function(){return p},contentTitle:function(){return l},default:function(){return h},frontMatter:function(){return s},metadata:function(){return c},toc:function(){return m}});var a=t(2848),r=t(9213),o=(t(9496),t(9613)),i=["components"],s={id:"performance",title:"Performance",sidebar_label:"Performance"},l=void 0,c={unversionedId:"advanced/performance",id:"advanced/performance",title:"Performance",description:"The Scene Graph can get extremely complicated which demands more and more resources of the devices. This section outlines some tips and tricks to improve the performance of rendering the Scene Graph in case we need it.",source:"@site/docs/advanced/performance.mdx",sourceDirName:"advanced",slug:"/advanced/performance",permalink:"/docs/advanced/performance",draft:!1,editUrl:"https://github.com/nartc/angular-three/tree/main/libs/documentations/docs/docs/advanced/performance.mdx",tags:[],version:"current",frontMatter:{id:"performance",title:"Performance",sidebar_label:"Performance"},sidebar:"docs",previous:{title:"Wrap existing component",permalink:"/docs/advanced/practices/wrap-existing-component"}},p={},m=[{value:"Re-use Geometries and Materials",id:"re-use-geometries-and-materials",level:2},{value:"Imperative",id:"imperative",level:3},{value:"Declarative",id:"declarative",level:3},{value:"On-demand Rendering",id:"on-demand-rendering",level:2},{value:"Instancing",id:"instancing",level:2},{value:"Level of Detail",id:"level-of-detail",level:2},{value:"Movement Regression",id:"movement-regression",level:2}],d={toc:m};function h(e){var n=e.components,t=(0,r.Z)(e,i);return(0,o.kt)("wrapper",(0,a.Z)({},d,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"The Scene Graph can get extremely complicated which demands more and more resources of the devices. This section outlines some tips and tricks to improve the performance of rendering the Scene Graph in case we need it."),(0,o.kt)("h2",{id:"re-use-geometries-and-materials"},"Re-use Geometries and Materials"),(0,o.kt)("p",null,"Each Geometry and Material consumes the GPU's resources. If we know that certain Geometries and/or Materials will repeat, we can reuse them."),(0,o.kt)("h3",{id:"imperative"},"Imperative"),(0,o.kt)("p",null,"We can have static geometries and materials as Component's properties"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},'@Component({\n  selector: \'app-scene\',\n  template: `\n    <ngt-mesh [position]="[1, 1, 1]" [geometry]="sphere" [material]="redMaterial"></ngt-mesh>\n    <ngt-mesh [position]="[2, 2, 2]" [geometry]="sphere" [material]="redMaterial"></ngt-mesh>\n  `,\n  changeDetection: ChangeDetectionStrategy.OnPush,\n})\nexport class SceneComponent {\n  readonly sphere = new THREE.SphereGeometry(1, 32, 32);\n  readonly redMaterial = new THREE.MeshStandardMaterial({ color: \'red\' });\n}\n')),(0,o.kt)("p",null,"For static geometries/materials like these, we can also store them in a Singleton Service like"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"@Injectable({ providedIn: 'root' })\nexport class StaticShapeService {\n  readonly redSphere = {\n    geometry: new THREE.SphereGeometry(1, 32, 32),\n    material: new THREE.MeshStandardMaterial({ color: 'red' }),\n  };\n}\n")),(0,o.kt)("p",null,"Now we can reuse them anywhere by injecting ",(0,o.kt)("inlineCode",{parentName:"p"},"StaticShapeService"),"."),(0,o.kt)("h3",{id:"declarative"},"Declarative"),(0,o.kt)("p",null,"There are also cases where we want to render the Geometries and/or Materials on the template so they can react to input changes but still want to reuse them."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},'@Component({\n  selector: \'app-scene\',\n  template: `\n    <ngt-sphere-geometry #sphereGeometry [args]="[1, 32, 32]" noAttach></ngt-sphere-geometry>\n    <ngt-mesh-standard-material #standardMaterial [color]="color" noAttach></ngt-mesh-standard-material>\n\n    <ngt-mesh\n      [position]="[1, 1, 1]"\n      [geometry]="sphereGeometry.instance"\n      [material]="standardMaterial.instance"\n    ></ngt-mesh>\n    <ngt-mesh\n      [position]="[2, 2, 2]"\n      [geometry]="sphereGeometry.instance"\n      [material]="standardMaterial.instance"\n    ></ngt-mesh>\n  `,\n  changeDetection: ChangeDetectionStrategy.OnPush,\n})\nexport class SceneComponent {}\n')),(0,o.kt)("p",null,"All components (in this case, geometries/materials) are derived from ",(0,o.kt)("inlineCode",{parentName:"p"},"NgtInstance"),". Hence, we can grab the underlying ",(0,o.kt)("inlineCode",{parentName:"p"},"instance")," by assigning the geometries/materials instances to Angular's Template Variables."),(0,o.kt)("div",{className:"admonition admonition-caution alert alert--warning"},(0,o.kt)("div",{parentName:"div",className:"admonition-heading"},(0,o.kt)("h5",{parentName:"div"},(0,o.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,o.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"16",height:"16",viewBox:"0 0 16 16"},(0,o.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M8.893 1.5c-.183-.31-.52-.5-.887-.5s-.703.19-.886.5L.138 13.499a.98.98 0 0 0 0 1.001c.193.31.53.501.886.501h13.964c.367 0 .704-.19.877-.5a1.03 1.03 0 0 0 .01-1.002L8.893 1.5zm.133 11.497H6.987v-2.003h2.039v2.003zm0-3.004H6.987V5.987h2.039v4.006z"}))),"caution")),(0,o.kt)("div",{parentName:"div",className:"admonition-content"},(0,o.kt)("p",{parentName:"div"},"All ",(0,o.kt)("inlineCode",{parentName:"p"},"NgtInstance")," has ",(0,o.kt)("a",{parentName:"p",href:"../core/instance#attaching"},"Automatic Attach"),". For Geometries/Materials that we want to reuse, we ",(0,o.kt)("strong",{parentName:"p"},"DO NOT")," want them to attach on any particular parent so we need to use ",(0,o.kt)("inlineCode",{parentName:"p"},"noAttach")," on them."))),(0,o.kt)("h2",{id:"on-demand-rendering"},"On-demand Rendering"),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"Credit: ",(0,o.kt)("a",{parentName:"p",href:"https://docs.pmnd.rs/react-three-fiber/advanced/scaling-performance#on-demand-rendering"},"React Three Fiber"))),(0,o.kt)("p",null,"The Scene Graph is ",(0,o.kt)("em",{parentName:"p"},"usually")," rendered at 60 times per second (60fps). This makes sense if the Scene Graph contains ",(0,o.kt)("em",{parentName:"p"},"constantly")," moving parts (like a game). Consequently, this is what drains the device's resources."),(0,o.kt)("p",null,"If the Scene Graph has static entities, or entities that are allowed to come to a rest, constantly rendering 60 times per second would be wasteful. In those cases, we can opt into on-demand rendering, which will only render when necessary. All we have to do is to set ",(0,o.kt)("inlineCode",{parentName:"p"},'frameloop="demand"')," on the ",(0,o.kt)("inlineCode",{parentName:"p"},"ngt-canvas")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-html"},'<ngt-canvas frameloop="demand"></ngt-canvas>\n')),(0,o.kt)("div",{className:"admonition admonition-info alert alert--info"},(0,o.kt)("div",{parentName:"div",className:"admonition-heading"},(0,o.kt)("h5",{parentName:"div"},(0,o.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,o.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,o.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"}))),"info")),(0,o.kt)("div",{parentName:"div",className:"admonition-content"},(0,o.kt)("p",{parentName:"div"},"Check out ",(0,o.kt)("a",{parentName:"p",href:"https://angular-three.netlify.app/examples/color-grading"},"Color Grading Example")," to see on-demand rendering in action. Notice the Stats stops ticking when the camera stops moving."))),(0,o.kt)("h2",{id:"instancing"},"Instancing"),(0,o.kt)("p",null,'WebGL works by requesting "draw call" from the GPU. Each Mesh that we put on our Canvas is a single draw call requested in which case we need to be mindful of how many draw calls we\'re requesting.'),(0,o.kt)("div",{className:"admonition admonition-info alert alert--info"},(0,o.kt)("div",{parentName:"div",className:"admonition-heading"},(0,o.kt)("h5",{parentName:"div"},(0,o.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,o.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,o.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"}))),"info")),(0,o.kt)("div",{parentName:"div",className:"admonition-content"},(0,o.kt)("p",{parentName:"div"},"From ",(0,o.kt)("a",{parentName:"p",href:"https://docs.pmnd.rs/react-three-fiber/advanced/scaling-performance#instancing"},"R3F Instancing"),', "no more than 1000 as the very maximum, and optimally a few hundred or less"'))),(0,o.kt)("p",null,"In THREE.js, there is a special Mesh called ",(0,o.kt)("a",{parentName:"p",href:"https://threejs.org/docs/index.html?q=instanced#api/en/objects/InstancedMesh"},"InstancedMesh"),". With InstancedMesh, we can render hundreds of thousands of objects in a single draw call if those objects have the same Geometry and Material."),(0,o.kt)("p",null,"Setting up InstancedMesh is not hard but it might be hard for people who are new to THREE. Please consult ",(0,o.kt)("a",{parentName:"p",href:"https://threejs.org/docs/index.html?q=instanced#api/en/objects/InstancedMesh"},"THREE.js InstancedMesh"),". Additionally, check out ",(0,o.kt)("a",{parentName:"p",href:"https://angular-three.netlify.app/examples/vertex-colors-instances"},"Vertex Colors Instances example")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},'@Component({\n  selector: \'sandbox-instances\',\n  template: `\n    <ngt-instanced-mesh (ready)="onReady($event)" [count]="length">\n      <ngt-box-geometry [args]="[0.15, 0.15, 0.15]">\n        <ngt-instanced-buffer-attribute\n          [attach]="[\'attributes\', \'color\']"\n          [args]="[colorArray, 3]"\n        ></ngt-instanced-buffer-attribute>\n      </ngt-box-geometry>\n      <ngt-mesh-lambert-material vertexColors toneMapped="false"></ngt-mesh-lambert-material>\n    </ngt-instanced-mesh>\n  `,\n  changeDetection: ChangeDetectionStrategy.OnPush,\n})\nexport class InstancesComponent {\n  readonly length = 125000;\n  readonly o = new THREE.Object3D();\n  readonly c = new THREE.Color();\n  readonly colors = Array.from({ length: this.length }, () => niceColor[Math.floor(Math.random() * 5)]);\n\n  colorArray = Float32Array.from(\n    Array.from({ length: this.length }, (_, index) =>\n      this.c.set(this.colors[index]).convertSRGBToLinear().toArray()\n    ).flat()\n  );\n\n  onReady($event: THREE.InstancedMesh) {\n    let i = 0;\n    for (let x = 0; x < 50; x++) {\n      for (let y = 0; y < 50; y++) {\n        for (let z = 0; z < 50; z++) {\n          const id = i++;\n          this.o.position.set(25 - x, 25 - y, 25 - z);\n          this.o.updateMatrix();\n          $event.setMatrixAt(id, this.o.matrix);\n        }\n      }\n    }\n    checkNeedsUpdate($event.instanceMatrix);\n  }\n}\n')),(0,o.kt)("h2",{id:"level-of-detail"},"Level of Detail"),(0,o.kt)("p",null,"Sometimes, it is beneficial to render a low-quality version of an object if it is far away from the camera. This makes sense because why we would want to display its full resolution if it is ",(0,o.kt)("em",{parentName:"p"},"barely")," visible. By rendering a low-quality object, we can reduce the load on the GPU which gains us back some performance."),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://threejs.org/docs/index.html?q=lod#api/en/objects/LOD"},"THREE.js LOD")," can help with this use-case. Check out ",(0,o.kt)("a",{parentName:"p",href:"https://angular-three.netlify.app/examples/level-of-detail"},"Level of Detail example")," and scroll around."),(0,o.kt)("h2",{id:"movement-regression"},"Movement Regression"),(0,o.kt)("p",null,"When inspect ",(0,o.kt)("a",{parentName:"p",href:"../core/store"},"NgtStore")," object, we will see a ",(0,o.kt)("inlineCode",{parentName:"p"},"performance")," object with the following shape"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},'{\n  "current": 1,\n  "min": 0.1,\n  "max": 1,\n  "debounce": 200,\n  "regress": () => {/*...*/}\n}\n')),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"current: Performance factor alternates between min and max"),(0,o.kt)("li",{parentName:"ul"},"min: Performance lower bound (should be less than 1)"),(0,o.kt)("li",{parentName:"ul"},"max: Performance upper bound (no higher than 1)"),(0,o.kt)("li",{parentName:"ul"},"debounce: Debounce timeout until it goes to upper bound (1) again"),(0,o.kt)("li",{parentName:"ul"},"regress(): Function that temporarily regresses performance")),(0,o.kt)("p",null,"The above object is the default ",(0,o.kt)("inlineCode",{parentName:"p"},"performance"),". We can customize this by provide the ",(0,o.kt)("inlineCode",{parentName:"p"},"NGT_PERFORMANCE_OPTIONS")," by calling ",(0,o.kt)("inlineCode",{parentName:"p"},"providePerformanceOptions()")," in ",(0,o.kt)("inlineCode",{parentName:"p"},"providers")," array"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"@Component({\n  template: ` <ngt-canvas></ngt-canvas> `,\n  providers: [providePerformanceOptions({ min: 0.5 })],\n})\nexport class AppComponent {}\n")),(0,o.kt)("p",null,"The crux here is we would want to call ",(0,o.kt)("inlineCode",{parentName:"p"},"regress()")," when we want to perform a performance regression. Eg: when we move the mouse, or when Controls updates etc..."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"@Component({})\nexport class OrbitControlsComponent {\n  constructor(private store: NgtStore) {}\n\n  ngOnInit() {\n    const performance = this.store.get((s) => s.performance);\n    this.controls.addEventListener('change', performance.regress);\n  }\n}\n")),(0,o.kt)("p",null,"Note that calling ",(0,o.kt)("inlineCode",{parentName:"p"},"regress()")," alone ",(0,o.kt)("strong",{parentName:"p"},"DOES NOT")," do anything. During ",(0,o.kt)("inlineCode",{parentName:"p"},"regress()"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"performance.current")," is adjusted. In other words, to actually perform a regression, we need to use ",(0,o.kt)("inlineCode",{parentName:"p"},"performance.current")," to calculate things like device pixel ratio, or turn off lights etc..."),(0,o.kt)("p",null,"Check out ",(0,o.kt)("a",{parentName:"p",href:"https://angular-three.netlify.app/examples/movement-regression"},"Movement Regression example")," for better ideas of how to achieve Performance Regression. Additionally, check out ",(0,o.kt)("a",{parentName:"p",href:"https://angular-three.netlify.app/soba?path=/story/performances-adaptive-dpr--default"},"AdaptiveDpr story")))}h.isMDXComponent=!0}}]);